use std::path::{Path, PathBuf};
use std::sync::mpsc::Sender;

use log::{debug, error};
use notify::event::{CreateKind, ModifyKind, RemoveKind};
use notify::{
    Config, Event as NotifyEvent, EventHandler, EventKind, INotifyWatcher, RecommendedWatcher, RecursiveMode, Watcher,
};

use super::subid::{ETC_SUBGID, ETC_SUBUID};
use crate::app::event::{AppEvent, Event, FileSystemChangeKind};

pub fn is_valid_file(path: &Path) -> bool {
    if path == Path::new(ETC_SUBGID) || path == Path::new(ETC_SUBUID) {
        return true;
    }

    match path.file_name().and_then(|f| f.to_str()) {
        Some(filename) if filename.ends_with(".conf") => {
            let prefix = &filename[..filename.len() - 5];
            !prefix.is_empty() && prefix.chars().all(|c| c.is_ascii_digit())
        },
        _ => false,
    }
}

pub struct FileEventHandler {
    app_tx: Sender<Event>,
    fs_tx: Sender<PathBuf>,
}

impl FileEventHandler {
    pub fn new(app_tx: Sender<Event>, fs_tx: Sender<PathBuf>) -> Self {
        Self { app_tx, fs_tx }
    }
}

impl EventHandler for FileEventHandler {
    fn handle_event(&mut self, event: Result<NotifyEvent, notify::Error>) {
        if let Ok(event) = event {
            for path in event.paths {
                if !is_valid_file(&path) {
                    continue;
                }

                match event.kind {
                    EventKind::Create(CreateKind::File) | EventKind::Modify(ModifyKind::Data(_)) => {
                        if self.fs_tx.send(path.clone()).is_err() {
                            error!("Failed to send file system change event {:?} for {path:?}", event.kind);
                        }
                    },
                    // REVIEW: Not sure if (re)name is correct:
                    EventKind::Modify(ModifyKind::Name(_)) | EventKind::Remove(RemoveKind::File) => {
                        if self
                            .app_tx
                            .send(Event::App(AppEvent::FileSystemChanged(FileSystemChangeKind::Remove(
                                path.clone(),
                            ))))
                            .is_err()
                        {
                            error!("Failed to send file system change event {:?} for {path:?}", event.kind);
                        }
                    },
                    e => {
                        debug!("Unsupported file system change kind: {e:?}");

                        continue;
                    },
                };
            }
        }
    }
}

#[derive(Debug)]
pub struct MonitorHandler {
    watcher: INotifyWatcher,
}

impl MonitorHandler {
    pub fn new(app_tx: Sender<Event>, fs_tx: Sender<PathBuf>, lxc_config_dir: &Path) -> notify::Result<Self> {
        let event_handler = FileEventHandler { app_tx, fs_tx };
        let mut watcher = RecommendedWatcher::new(event_handler, Config::default())?;

        watcher.watch(Path::new(ETC_SUBGID), RecursiveMode::NonRecursive)?;
        watcher.watch(Path::new(ETC_SUBUID), RecursiveMode::NonRecursive)?;
        watcher.watch(lxc_config_dir, RecursiveMode::Recursive)?;

        Ok(Self { watcher })
    }

    pub fn watch_rootfs(&mut self, rootfs: &Path) -> notify::Result<()> {
        self.watcher.watch(rootfs, RecursiveMode::NonRecursive)
    }
}
